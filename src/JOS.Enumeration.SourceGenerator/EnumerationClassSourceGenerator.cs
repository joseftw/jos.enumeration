using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace JOS.Enumeration.SourceGenerator;

[Generator]
public class EnumerationClassSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var recordDeclarations = EnumerationHelpers.GetEnumerationRecordDeclarations(context);
        var incrementalValueProvider = context.CompilationProvider.Combine(recordDeclarations);
        context.RegisterSourceOutput(
            incrementalValueProvider, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<RecordDeclarationSyntax> enumerations,
        SourceProductionContext context)
    {
        if(enumerations.IsDefaultOrEmpty)
        {
            return;
        }

        context.CancellationToken.ThrowIfCancellationRequested();
        var @namespace = compilation.Assembly.Identity.Name;
        var source = $$"""
            {{SourceGenerationHelpers.AutoGenerated}}
            {{SourceGenerationHelpers.Nullable}}
            using System;
            using System.Collections.Generic;
            using JOS.Enumeration;

            namespace {{@namespace}};

            public static class Enumeration
            {
                public static IEnumerable<T> GetAll<T>() where T : IEnumeration<T>
                {
                    {{GetAllMethodBody(compilation, enumerations)}}
                }

                public static T FromValue<T>(int value) where T : class, IEnumeration<T>
                {
                    {{FromValueBody(compilation, enumerations)}}
                }

                public static T FromDisplayName<T>(string displayName) where T : class, IEnumeration<T>
                {
                    {{FromDisplayNameBody(compilation, enumerations)}}
                }
            }
            """;

#if DEBUG
source = CSharpSyntaxTree.ParseText(source).GetRoot().NormalizeWhitespace().SyntaxTree.GetText().ToString();
#endif
        context.AddSource("Enumeration.Generated.Implementation.cs", source);
    }

    private static string GetAllMethodBody(
        Compilation compilation, ImmutableArray<RecordDeclarationSyntax> recordDeclarationSyntaxes)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("var type = typeof(T);");
        foreach(var field in recordDeclarationSyntaxes)
        {
            var symbol = ModelExtensions.GetDeclaredSymbol(compilation.GetSemanticModel(field.SyntaxTree), field)!;
            stringBuilder.AppendLine($"if(type == typeof({symbol}))");
            stringBuilder.Append("{");
            stringBuilder.Append($"return (IEnumerable<T>){symbol}.GetAll();");
            stringBuilder.Append("}");
        }

        stringBuilder.AppendLine("throw new NotSupportedException($\"'{type}' is not supported\");");
        return stringBuilder.ToString();
    }

    private static string FromValueBody(
        Compilation compilation, ImmutableArray<RecordDeclarationSyntax> recordDeclarationSyntaxes)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("var type = typeof(T);");
        foreach(var field in recordDeclarationSyntaxes)
        {
            var symbol = ModelExtensions.GetDeclaredSymbol(compilation.GetSemanticModel(field.SyntaxTree), field)!;
            stringBuilder.AppendLine($"if(type == typeof({symbol}))");
            stringBuilder.Append("{");
            stringBuilder.Append($"return ({symbol}.FromValue(value) as T)!;");
            stringBuilder.Append("}");
        }

        stringBuilder.AppendLine("throw new NotSupportedException($\"'{type}' is not supported\");");
        return stringBuilder.ToString();
    }

    private static string FromDisplayNameBody(
        Compilation compilation, ImmutableArray<RecordDeclarationSyntax> recordDeclarationSyntaxes)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("var type = typeof(T);");
        foreach(var field in recordDeclarationSyntaxes)
        {
            var symbol = ModelExtensions.GetDeclaredSymbol(compilation.GetSemanticModel(field.SyntaxTree), field)!;
            stringBuilder.AppendLine($"if(type == typeof({symbol}))");
            stringBuilder.Append("{");
            stringBuilder.Append($"return ({symbol}.FromDisplayName(displayName) as T)!;");
            stringBuilder.Append("}");
        }

        stringBuilder.AppendLine("throw new NotSupportedException($\"'{type}' is not supported\");");
        return stringBuilder.ToString();
    }
}
