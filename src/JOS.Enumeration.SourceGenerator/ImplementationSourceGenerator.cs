using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace JOS.Enumeration.SourceGenerator;

[Generator]
public class ImplementationSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var recordDeclarations = EnumerationHelpers.GetEnumerationRecordDeclarations(context);
        var incrementalValueProvider = context.CompilationProvider.Combine(recordDeclarations);
        context.RegisterSourceOutput(
            incrementalValueProvider, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<RecordDeclarationSyntax> enumerations,
        SourceProductionContext context)
    {
        if(enumerations.IsDefaultOrEmpty)
        {
            return;
        }

        foreach(var enumeration in enumerations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var symbol = ModelExtensions.GetDeclaredSymbol(compilation.GetSemanticModel(enumeration.SyntaxTree), enumeration)!;
            var @namespace = symbol.ContainingNamespace;
            var fieldDeclarationSyntaxes =
                enumeration.Members.Where(x => x is FieldDeclarationSyntax).Cast<FieldDeclarationSyntax>().ToList();
            var items = ExtractEnumerationItems(fieldDeclarationSyntaxes);
            var source = $$"""
            {{SourceGenerationHelpers.AutoGenerated}}
            {{SourceGenerationHelpers.Nullable}}
            using System;
            using System.Collections.Generic;
            using JOS.Enumeration;

            namespace {{@namespace}};

            {{enumeration.Modifiers}} record {{symbol.MetadataName}} : IComparable<{{symbol.MetadataName}}>
            {
                private {{symbol.MetadataName}}(int value, string displayName)
                {
                    Value = value;
                    DisplayName = displayName ?? throw new ArgumentNullException(nameof(displayName));
                }

                public int Value {get; }
                public string DisplayName {get; }

                public static IEnumerable<{{symbol.MetadataName}}> GetAll()
                {
                    {{GetAllMethodBody(items)}}
                }

                public static {{symbol.MetadataName}} FromValue(int value)
                {
                    {{FromValueMethodBody(items, symbol)}}
                }

                public static {{symbol.MetadataName}} FromDisplayName(string displayName)
                {
                    {{FromDisplayNameBody(items, symbol)}}
                }

                public int CompareTo({{symbol.MetadataName}}? other) => Value.CompareTo(other!.Value);
                public static implicit operator int({{symbol.MetadataName}} item) => item.Value;
                public static implicit operator {{symbol.MetadataName}}(int value) => FromValue(value);
            }
            """;
#if DEBUG
            source = CSharpSyntaxTree.ParseText(source).GetRoot().NormalizeWhitespace().SyntaxTree.GetText().ToString();
#endif
            context.AddSource($"{symbol.MetadataName}.Generated.Implementation.cs", source);
        }
    }

    private static string GetAllMethodBody(IEnumerable<EnumerationItem> items)
    {
        var stringBuilder = new StringBuilder();
        foreach(var item in items)
        {
            stringBuilder.AppendLine($"yield return {item.FieldName};");
        }

        return stringBuilder.ToString();
    }

    private static string FromValueMethodBody(IEnumerable<EnumerationItem> items, ISymbol enumerationSymbol)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("return value switch");
        stringBuilder.AppendLine("{");
        foreach(var field in items)
        {
            stringBuilder.AppendLine($"{field.Value} => {field.FieldName},");
        }

        stringBuilder.AppendLine(
            $"_ => throw new InvalidOperationException($\"'{{value}}' is not a valid value in '{enumerationSymbol}'\")");
        stringBuilder.Append("};");
        return stringBuilder.ToString();
    }

    private static string FromDisplayNameBody(IEnumerable<EnumerationItem> items, ISymbol enumerationSymbol)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("return displayName switch");
        stringBuilder.AppendLine("{");
        foreach(var field in items)
        {
            stringBuilder.AppendLine($"\"{field.DisplayName}\" => {field.FieldName},");
        }

        stringBuilder.AppendLine(
            $"_ => throw new InvalidOperationException($\"'{{displayName}}' is not a valid display name in '{enumerationSymbol}'\")");
        stringBuilder.Append("};");
        return stringBuilder.ToString();
    }

    private static IReadOnlyCollection<EnumerationItem> ExtractEnumerationItems(
        IReadOnlyCollection<FieldDeclarationSyntax> fields)
    {
        var items = new List<EnumerationItem>(fields.Count);
        foreach(var field in fields)
        {
            var variable = field.Declaration.Variables.First();
            var objectCreationExpression = (ImplicitObjectCreationExpressionSyntax)variable.Initializer!.Value;
            var arguments = objectCreationExpression.ArgumentList.Arguments;
            var value = (int)((LiteralExpressionSyntax)arguments[0].Expression).Token.Value!;
            var displayName = (string)((LiteralExpressionSyntax)arguments[1].Expression).Token.Value!;
            var fieldName = variable.Identifier.Value!.ToString();
            items.Add(new EnumerationItem(value, displayName, fieldName));
        }

        return items;
    }
}
