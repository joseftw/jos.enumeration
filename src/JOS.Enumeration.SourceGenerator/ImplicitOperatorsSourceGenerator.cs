using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace JOS.Enumeration.SourceGenerator;

[Generator]
public class ImplicitOperatorsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var recordDeclarations = EnumerationHelpers.GetRecordDeclarations(context);
        var incrementalValueProvider = context.CompilationProvider.Combine(recordDeclarations);
        context.RegisterSourceOutput(
            incrementalValueProvider, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static void Execute(
        Compilation compilation, ImmutableArray<RecordDeclarationSyntax> enumerations, SourceProductionContext context)
    {
        if (enumerations.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var enumeration in enumerations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var symbol = compilation.GetSemanticModel(enumeration.SyntaxTree).GetDeclaredSymbol(enumeration)!;
            var @namespace = symbol.ContainingNamespace;
            var source = $$"""
            {{SourceGenerationHelpers.AutoGenerated}}
            {{SourceGenerationHelpers.Nullable}}

            using JOS.Enumeration;

            namespace {{@namespace}};

            {{enumeration.Modifiers}} record {{symbol.MetadataName}} : Enumeration<{{symbol.MetadataName}}>
            {
                public static implicit operator int({{symbol.MetadataName}} item) => item.Value;
                public static implicit operator {{symbol.MetadataName}}(int value) => FromValue(value);
            }
            """;

            context.AddSource($"{symbol.MetadataName}.Generated.Implicit.cs", source);
        }
    }
}
