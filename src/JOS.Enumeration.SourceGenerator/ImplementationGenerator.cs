using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace JOS.Enumeration.SourceGenerator;

internal static class ImplementationGenerator
{
    internal static void Generate(
        Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> enumerations,
        SourceProductionContext context)
    {
        if(enumerations.IsDefaultOrEmpty)
        {
            return;
        }

        foreach(var enumeration in enumerations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var symbol = compilation.GetSemanticModel(enumeration.SyntaxTree).GetDeclaredSymbol(enumeration)!;
            var @namespace = symbol.ContainingNamespace;
            var typeSymbol = (ITypeSymbol)symbol;
            var enumerationInterface =
                typeSymbol.AllInterfaces.Single(x => x.Name == "IEnumeration" && x.TypeArguments.Length == 2);
            var valueType = enumerationInterface.TypeArguments.First();
            var fieldDeclarationSyntaxes =
                enumeration.Members.Where(x => x is FieldDeclarationSyntax).Cast<FieldDeclarationSyntax>().ToList();
            var items =
                SourceGenerationHelpers.ExtractEnumerationItems(fieldDeclarationSyntaxes).WithoutDuplicates();
            var source = $$"""
            {{SourceGenerationHelpers.AutoGenerated}}
            {{SourceGenerationHelpers.Nullable}}
            using System;
            using System.Collections;
            using System.Collections.Generic;
            #if NET8_0_OR_GREATER
            using System.Collections.Frozen;
            #endif
            using JOS.Enumeration;

            namespace {{@namespace}};

            [System.Diagnostics.DebuggerDisplay("{Description}")]
            {{enumeration.Modifiers}} {{enumeration.Keyword.Value}} {{symbol.MetadataName}}
                : {{GenerateInterfaces(symbol, enumeration)}}
            {
                private static readonly IReadOnlySet<{{symbol}}> AllItems;

                static {{symbol.MetadataName}}()
                {
                    #if NET8_0_OR_GREATER
                    AllItems = new HashSet<{{symbol}}>({{items.Count}})
                    {
                        {{AllItemsSet(items)}}
                    }.ToFrozenSet();
                    #else
                    AllItems = new HashSet<{{symbol}}>({{items.Count}})
                    {
                        {{AllItemsSet(items)}}
                    };
                    #endif
                }

                private {{symbol.MetadataName}}({{valueType}} value, string description)
                {
                    Value = value;
                    Description = description ?? throw new ArgumentNullException(nameof(description));
                }

                public {{valueType}} Value { get; }
                public string Description { get; }

                public static IReadOnlySet<{{symbol}}> GetAll()
                {
                    return AllItems;
                }

                public static IEnumerable<{{symbol}}> GetEnumerable()
                {
                    {{GetEnumeratorBody(items)}}
                }

                public static {{symbol}} FromValue({{valueType}} value)
                {
                    {{FromValueMethodBody(valueType.OriginalDefinition, items, symbol)}}
                }

                public static {{symbol}} FromDescription(string description)
                {
                    {{FromDescriptionBody(items, symbol)}}
                }

                public static {{symbol}} FromDescription(ReadOnlySpan<char> description)
                {
                    {{FromDescriptionBody(items, symbol)}}
                }

                public static Type ValueType => typeof({{valueType}});

                public int CompareTo({{symbol}}? other) => Value.CompareTo(other!.Value);
                public static implicit operator {{valueType.OriginalDefinition}}({{symbol}} item) => item.Value;
                public static implicit operator {{symbol}}({{valueType.OriginalDefinition}} value) => FromValue(value);

                {{ClassSpecificMethods(symbol, enumeration)}}
            }
            """;

            context.AddSource($"{symbol.MetadataName}.Generated.Implementation.cs", source.FormatSource());
        }
    }

    private static string GenerateInterfaces(ISymbol symbol, TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration switch
        {
            RecordDeclarationSyntax => $"IComparable<{symbol}>",
            ClassDeclarationSyntax => $"IComparable<{symbol}>, IEquatable<{symbol}>",
            _ => throw new NotSupportedException($"{typeDeclaration} is not supported")
        };
    }

    private static string ClassSpecificMethods(ISymbol symbol, TypeDeclarationSyntax typeDeclaration)
    {
        if(typeDeclaration is RecordDeclarationSyntax)
        {
            return String.Empty;
        }

        var typeSymbol = (ITypeSymbol)symbol;
        var userDefinedMethods =
            typeSymbol.GetMembers()
                      .Where(x => x is IMethodSymbol
                      {
                          MethodKind: not (MethodKind.Constructor or MethodKind.StaticConstructor)
                      })
                      .Cast<IMethodSymbol>()
                      .Select(x =>
                      {
                          var parameters = x.Parameters;
                          if(!parameters.Any())
                          {
                              return $"{x.Name}()";
                          }

                          var parametersString = string.Join(",", x.Parameters.Select(p => p.ToString()));
                          return string.Concat($"{x.Name}(", parametersString, ")");
                      })
                      .ToImmutableHashSet();

        var stringBuilder = new StringBuilder(3);

        if(!userDefinedMethods.Any(x => x.StartsWith("Equals(object?")))
        {
            var equalsMethod = $$"""
            public override bool Equals(object? obj)
            {
                if (!(obj is {{symbol}} other))
                {
                    return false;
                }

                return Value.Equals(other.Value);
            }
            """;
            stringBuilder.AppendLine(equalsMethod);
        }

        if(!userDefinedMethods.Any(x => x.StartsWith($"Equals({symbol}?")))
        {
            var genericEqualsMethod = $$"""
            public bool Equals({{symbol}}? other)
            {
                return Value.Equals(other?.Value);
            }
            """;
            stringBuilder.AppendLine(genericEqualsMethod);
        }

        if(!userDefinedMethods.Any(x => x.StartsWith("GetHashCode(")))
        {
            var getHashCodeMethod = """
            public override int GetHashCode()
            {
                return HashCode.Combine(Value);
            }
            """;
            stringBuilder.AppendLine(getHashCodeMethod);
        }

        return stringBuilder.ToString();
    }

    private static string GetEnumeratorBody(IEnumerable<EnumerationItem> items)
    {
        var stringBuilder = new StringBuilder();
        foreach(var item in items)
        {
            stringBuilder.AppendLine($"yield return {item.FieldName};");
        }

        return stringBuilder.ToString();
    }

    private static string AllItemsSet(IEnumerable<EnumerationItem> items)
    {
        var stringBuilder = new StringBuilder();
        foreach(var item in items)
        {
            stringBuilder.AppendLine($"{item.FieldName},");
        }

        return stringBuilder.ToString();
    }

    private static string FromValueMethodBody(
        ITypeSymbol typeSymbol, IEnumerable<EnumerationItem> items, ISymbol enumerationSymbol)
    {
        var wrapInQuotes = ShouldWrapInQuotes(typeSymbol.Name);
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("return value switch");
        stringBuilder.AppendLine("{");
        foreach(var field in items)
        {
            var value = field.Value;
            if(wrapInQuotes)
            {
                value = WrapValueInQuotes(value);
            }

            if(value is bool)
            {
                value = value.ToString()!.ToLower();
            }

            stringBuilder.AppendLine($"{value} => {field.FieldName},");
        }

        if(ShouldAppendDefaultThrowCase(typeSymbol))
        {
            stringBuilder.AppendLine(
                $"_ => throw new InvalidOperationException($\"'{{value}}' is not a valid value in '{enumerationSymbol}'\")");
        }

        stringBuilder.Append("};");
        return stringBuilder.ToString();

        static bool ShouldAppendDefaultThrowCase(ITypeSymbol typeSymbol)
        {
            return typeSymbol.OriginalDefinition.ToString() switch
            {
                "bool" => false,
                _ => true
            };
        }
    }

    private static string FromDescriptionBody(IEnumerable<EnumerationItem> items, ISymbol enumerationSymbol)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("return description switch");
        stringBuilder.AppendLine("{");
        foreach(var field in items)
        {
            stringBuilder.AppendLine($"\"{field.Description}\" => {field.FieldName},");
        }

        stringBuilder.AppendLine(
            $"_ => throw new InvalidOperationException($\"'{{description}}' is not a valid description in '{enumerationSymbol}'\")");
        stringBuilder.Append("};");
        return stringBuilder.ToString();
    }

    private static bool ShouldWrapInQuotes(string valueType)
    {
        return valueType.ToLowerInvariant() switch
        {
            "string" => true,
            _ => false
        };
    }

    private static string WrapValueInQuotes(object value)
    {
        return $"\"{value}\"";
    }
}
